# -*- coding: utf-8 -*-
"""Copy of bankLoan.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vALv3yhMYsUJSaUeP3lIUUhvsAsSNXJq
"""

import matplotlib.pyplot as plt
import numpy as np
from math import *
from numpy import *
import seaborn as sns
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn import *
from sklearn.experimental import enable_iterative_imputer
from sklearn.impute import IterativeImputer
from sklearn.ensemble import RandomForestRegressor

from google.colab import drive
drive.mount('/content/drive')

train=pd.read_csv("/content/drive/MyDrive/Bank_Loan_Project/train.csv")
test=pd.read_csv("/content/drive/MyDrive/Bank_Loan_Project/test.csv")
ss=pd.read_csv("/content/drive/MyDrive/Bank_Loan_Project/sample.csv")

# print(shape(test))

#print(train.head())

data=pd.concat([train,test])
#print(data)
#data.describe()

data=pd.concat([train,test])
#print(data)
data.drop("Loan_ID", axis=1, inplace=True)
#print(data)

#data.describe()

data.isnull().sum()



for i in [data]:
  i["Gender"]=i["Gender"].fillna(data.Gender.dropna().mode()[0])
  i["Married"]=i["Married"].fillna(data.Married.dropna().mode()[0])
  i["Dependents"]=i["Dependents"].fillna(data.Dependents.dropna().mode()[0])
  i["Self_Employed"]=i["Self_Employed"].fillna(data.Self_Employed.dropna().mode()[0])
  i["Credit_History"]=i["Credit_History"].fillna(data.Credit_History.dropna().mode()[0])
  i["Loan_Amount_Term"]=i["Loan_Amount_Term"].fillna(data.Loan_Amount_Term.dropna().mode()[0])
  i["LoanAmount"]=i["LoanAmount"].fillna(data.LoanAmount.dropna().mode()[0])
  i["Loan_Status"]=i["Loan_Status"].fillna(data.Loan_Status.dropna().mode()[0])

  # i["EMI_per_Loan_Amount_Term"]=i["EMI_per_Loan_Amount_Term"].fillna(data.EMI_per_Loan_Amount_Term.dropna().mode()[0])
  # i["EMI_per_LoanAmount"]=i["EMI_per_LoanAmount"].fillna(data.EMI_per_LoanAmount.dropna().mode()[0])
# print(data)  
data.isnull().sum()

data1=data.loc[:,['LoanAmount','Loan_Amount_Term']]
imp=IterativeImputer(RandomForestRegressor(),max_iter=10,random_state=0)
data1=pd.DataFrame(imp.fit_transform(data1),columns=data1.columns)
#print(data1)

for i in [data]:
  i["Gender"]=i["Gender"].map({"Male":0,  "Female":1}).astype(int)
  i["Married"]=i["Married"].map({'No':0,  "Yes":1}).astype(int)
  i["Education"]=i["Education"].map({"Not Graduate":0,  "Graduate":1}).astype(int)
  i["Self_Employed"]=i["Self_Employed"].map({'No':0,  "Yes":1}).astype(int)
  i["Credit_History"]=i["Credit_History"].astype(int)

for i in [data]:
  i["Property_Area"]=i["Property_Area"].map({"Urban":0, "Rural":1, "Semiurban":2}).astype(int)
  i["Dependents"]=i["Dependents"].map({"0":0, "1":1, "2":2, "3+":3}).astype(int)

# new_train=data.iloc[:614]
# new_test=data.iloc[614:]
new_train=data.iloc[:800]
new_test=data.iloc[800:]

new_train["Loan_Status"]=new_train["Loan_Status"].map({'N':0,"Y":1}).astype(int)

"""fig,ax=plt.subplots(2,4,figsize=(16,10))
sns.countplot('Loan_Status',data=new_train, ax=ax[0][0])
sns.countplot('Gender',data=new_train, ax=ax[0][1])
sns.countplot('Married',data=new_train, ax=ax[0][2])
sns.countplot('Education',data=new_train, ax=ax[0][3])
sns.countplot('Self_Employed',data=new_train, ax=ax[1][0])
sns.countplot('Property_Area',data=new_train, ax=ax[1][1])
sns.countplot('Credit_History',data=new_train, ax=ax[1][2])
sns.countplot('Dependents',data=new_train, ax=ax[1][3])

sns.boxplot(x='Loan_Status', y='ApplicantIncome', data=new_train)
sns.boxplot(x='Loan_Status', y='CoapplicantIncome', data=new_train)
sns.catplot(x='Gender', y='LoanAmount', data=new_train, kind='box')
sns.catplot(x='Gender', y='LoanAmount',data=data, kind='box',hue='Loan_Status', col='Married')
sns.catplot(x='Gender', y='CoapplicantIncome', data=data, kind='boxen', hue='Loan_Status', col='Property_Area')
"""

#sns.boxplot(x='Loan_Status', y='CoapplicantIncome', data=new_train)

#sns.catplot(x='Gender', y='LoanAmount', data=new_train, kind='box')

#sns.catplot(x='Gender', y='LoanAmount',data=data, kind='box',hue='Loan_Status', col='Married')

#sns.catplot(x='Gender', y='CoapplicantIncome', data=data, kind='boxen', hue='Loan_Status', col='Property_Area')

from mpl_toolkits.mplot3d import Axes3D
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt # plotting
import numpy as np # linear algebra
import os # accessing directory structure
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
def plotPerColumnDistribution(df, nGraphShown, nGraphPerRow):
    nunique = df.nunique()
    df = df[[col for col in df if nunique[col] > 1 and nunique[col] < 50]] # For displaying purposes, pick columns that have between 1 and 50 unique values
    nRow, nCol = df.shape
    columnNames = list(df)
    nGraphRow = (nCol + nGraphPerRow - 1) / nGraphPerRow
    plt.figure(num = None, figsize = (6 * nGraphPerRow, 8 * nGraphRow), dpi = 80, facecolor = 'w', edgecolor = 'k')
    for i in range(min(nCol, nGraphShown)):
        plt.subplot(nGraphRow, nGraphPerRow, i + 1)
        columnDf = df.iloc[:, i]
        if (not np.issubdtype(type(columnDf.iloc[0]), np.number)):
            valueCounts = columnDf.value_counts()
            valueCounts.plot.bar()
        else:
            columnDf.hist()
        plt.ylabel('counts')
        plt.xticks(rotation = 90)
        plt.title(f'{columnNames[i]} (column {i})')
    plt.tight_layout(pad = 1.0, w_pad = 1.0, h_pad = 1.0)
    #plt.show()
plotPerColumnDistribution(data, 10, 5)
# plotPerColumnDistribution(data, 10, 5)

def plotScatterMatrix(df, plotSize, textSize):
    df = df.select_dtypes(include =[np.number]) # keep only numerical columns
    # Remove rows and columns that would lead to df being singular
    df = df.dropna('columns')
    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values
    columnNames = list(df)
    if len(columnNames) > 10: # reduce the number of columns for matrix inversion of kernel density plots
        columnNames = columnNames[:10]
    df = df[columnNames]
    ax = pd.plotting.scatter_matrix(df, alpha=0.75, figsize=[plotSize, plotSize], diagonal='kde')
    corrs = df.corr().values
    for i, j in zip(*plt.np.triu_indices_from(ax, k = 1)):
        ax[i, j].annotate('Corr. coef = %.3f' % corrs[i, j], (0.8, 0.2), xycoords='axes fraction', ha='center', va='center', size=textSize)
    plt.suptitle('Scatter and Density Plot')
    #plt.show()

#plotScatterMatrix(data, 20, 10)

#sns.pairplot(data1)

# sample.describe()

"""
plt.figure(figsize=(10,10))
correlation_matrix=new_train.corr()
sns.heatmap(correlation_matrix,annot=True)
plt.show()
"""

for i in [data]:
  i["TotalIncome"]=i["ApplicantIncome"]+i["CoapplicantIncome"]

r=0.00833
data['EMI']=data.apply(lambda x: (x['LoanAmount']*r*((1+r)**x[('Loan_Amount_Term')]))/((1+r)**((x['Loan_Amount_Term'])-1)),axis=1)

data['Dependents_EMI_mean']=data.groupby(['Dependents'])['EMI'].transform('mean')
data['LoanAmount_per_TotalIncome']=data['LoanAmount']/data['TotalIncome']
data['LoanAmount_per_TotalIncome']=data['Loan_Amount_Term']/data['TotalIncome']
data['EMI_per_Loan_Amount_Term']=data['EMI']/data['Loan_Amount_Term']
data['EMI_per_LoanAmount']=data['EMI']/data['LoanAmount']
data['Property_Area_LoanAmount_per_TotalIncome_mean']=data.groupby(['Property_Area'])['LoanAmount_per_TotalIncome'].transform('mean')
data['Credit_History_Income_Sum']=data.groupby(['Credit_History'])['TotalIncome'].transform('sum')
data['Dependents_LoanAmount_Sum']=data.groupby(['Dependents'])['LoanAmount'].transform('sum')

from sklearn.preprocessing import KBinsDiscretizer
Loan_Amount_Term_discretizer= KBinsDiscretizer(n_bins=5, encode='ordinal', strategy='quantile')
data['Loan_Amount_Term_Bins']=Loan_Amount_Term_discretizer.fit_transform(data['Loan_Amount_Term'].values.reshape(-1,1)).astype(float)

TotalIncome_discretizer= KBinsDiscretizer(n_bins=5, encode='ordinal', strategy='quantile')
data['TotalIncome_Bins']=TotalIncome_discretizer.fit_transform(data['TotalIncome'].values.reshape(-1,1)).astype(float)
LoanAmount_per_TotalIncome_discretizer= KBinsDiscretizer(n_bins=5, encode='ordinal', strategy='quantile')
data['LoanAmount_per_TotalIncome_Bins']=LoanAmount_per_TotalIncome_discretizer.fit_transform(data['LoanAmount_per_TotalIncome'].values.reshape(-1,1)).astype(float)

data=data.drop(['EMI'],axis=1)
data=data.drop(['TotalIncome'],axis=1)
data=data.drop(['LoanAmount_per_TotalIncome'],axis=1)

new_train.shape

x=new_train.drop("Loan_Status", axis=1)
y=new_train["Loan_Status"]
new_train.head()

dd=pd.DataFrame({
    'Gender':0,
    'Married':0,'Dependents':3,'Education':1,'Self_Employed':0,'ApplicantIncome':9167,'CoapplicantIncome':0,
    'LoanAmount':185,'Loan_Amount_Term':360,'Credit_History':1,'Property_Area':1
},index=[0])

x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.3)
print(x_train.shape)
print(x_test.shape)

# x_test.to_csv('/content/drive/MyDrive/Bank_Loan_Project/textFile.csv') 
# # x_test=pd.read_csv("/content/drive/MyDrive/Bank_Loan_Project/textFile.csv")
# x_test.head()

from sklearn import linear_model
from sklearn.metrics import accuracy_score
log_clf=linear_model.LogisticRegression()
from sklearn.model_selection import cross_val_score
from sklearn.metrics import make_scorer
predo=log_clf.fit(x_train,y_train).predict(x_test)
# print(predo)
# print(y_test[:50])
accuracy_score(predo,y_test)
print(x_train.shape)
print(log_clf.score(x_train, y_train))




cross_val_score(log_clf,x_train,y_train,scoring=make_scorer(accuracy_score),cv=3)

array([0.8041958,0.7902097,0.7972028])
predo=log_clf.fit(x_train,y_train).predict(x_test)
print(x_test.head(1))
print(predo)
acr=accuracy_score(predo,y_test)

print("Accuracy= ",acr*100, "%")

#pip install flask-ngrok
#from flask_ngrok import run_with_ngrok

#define metrics
y_pred_proba = log_clf.predict_proba(x_test)[::,1]
fpr, tpr, _ = metrics.roc_curve(y_test,  y_pred_proba)

#create ROC curve
y_pred_proba = log_clf.predict_proba(x_test)[::,1]
fpr, tpr, _ = metrics.roc_curve(y_test,  y_pred_proba)
auc = metrics.roc_auc_score(y_test, y_pred_proba)
plt.plot(fpr,tpr,label="text_data, auc="+str(auc))
plt.legend(loc=4)
plt.show()
acr=accuracy_score(predo,y_test)
print("Accuracy= ",acr*100, "%")

from sklearn.metrics import classification_report
# LRcl=LogisticRegression(solver='saga', max_iter=500, random_state=1)
y_pred=log_clf.predict_proba(x_test)[::,1]
# print(classification_report(y_test,  y_pred_proba))
# target_names = ['class 0', 'class 1', 'class 2']
# print(y_test)
##print(y_pred)
# for i in range(y_pred.size):
#   if i>.75:
#     y_pred[i]=bool(1)
#   else:
#     y_pred[i]=bool(0)
##print(y_pred)
# print(classification_report(y_test, y_pred, target_names=target_names))

"""                    **ROC**"""

# #define metrics
# y_pred_proba = log_clf.predict_proba(x_test)[::,1]
# fpr, tpr, _ = metrics.roc_curve(y_test,  y_pred_proba)
# auc = metrics.roc_auc_score(y_test, y_pred_proba)

# #create ROC curve
# plt.plot(fpr,tpr,label="AUC="+str(auc))
# plt.ylabel('True Positive Rate')
# plt.xlabel('False Positive Rate')
# plt.legend(loc=4)
# plt.show()
# acr=accuracy_score(predo,y_test)
# print("Accuracy= ",acr*100, "%")

"""                        **AUC**"""

x_test.head()

print("Accuracy= ",acr*100, "%")

hj=log_clf.fit(x_train,y_train).predict(x_test)
test_df=pd.DataFrame(data=hj, columns=["Loan_Status"])

test_df=pd.DataFrame(data=hj,columns=["Loan_Status"])
final_pred = pd.concat([ss['Loan_ID'],test_df],axis=1)
# final_pred.to_csv("FinalFile.csv",index=False)

final_pred.to_csv('/content/drive/MyDrive/Bank_Loan_Project/FinalFile.csv') 

# df.to_csv('data.csv')
# !cp data.csv "drive/My Drive/"