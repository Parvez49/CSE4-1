# -*- coding: utf-8 -*-
"""RandomNumberGeneratorAss.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u5z4GtldDSdL_Vjun8DiGpw087zDfmBf
"""

import random as rnd
import math


def Input_Output(m1,m2,a1,a2,seed1,seed2,cycle,R,d,z):
  print("-----------------Implemention of a combined linear congruential generator-------------------")
  print()
  print("***************Input for Linear Congruential Generator***************")
  print("m1: 487")
  print("a1: 401")
  print("seed value 1st LCG: 387")

  print("m2: 159")
  print("a2: 343")
  print("seed value 2nd LCG: 59")
  print()

  print("*************Output for Combined Linear Congruential Generator**************")
  print("Cycle length of CLCG: ",cycle)
  print("300 Random Number: ")
  print_len=15
  j=0
  for i in R[0:300]:
    print("{:.4f}".format(i),end=" ")
    j+=1
    if j==print_len:
      print()
      j=0

  print()
  print("Uniform test: ")
  print("Kolmogorov_Smirnov: ")
  print("D value is: ",d)
  print("D value for this random number from tabel: 0.061")
  print("Our D value is smaller. So this is not rejected.")

  print()
  print("Autocorrelation tests: ")
  print("Value of Z: ",z)
  print("Z value for this random number from z table: 1.96")
  print("Our Z is smaller. So this hypothesis is not rejected.")

  
 
def CLCG(m1,m2,a1,a2,seed1,seed2,R):
    Y1=seed1
    Y2=seed2
    Y1 = a1 * Y1 % m1
    Y2 = a2 * Y2 % m2
    X = (Y1 - Y2) % (m1 - 1)
    preX=X
    cycle=1
    #for i in range (1, n):
    while True:
      #print(X)
      if (X > 0):
        R.append(X/m1)
      elif (X == 0):
        R.append((m1-1)/m1)
      Y1 = a1 * Y1 % m1
      Y2 = a2 * Y2 % m2
      X = (Y1 - Y2) % (m1 - 1)
      if X!=preX:
        cycle+=1
      else : break
    #print(X)
    
    return cycle

def Kolmogorov_Smirnov(R,n):
    R=sorted(R)
    d_plus = 0
    d_minus = 0
    i = 1
    for value in R:
        d_plus_i = ( (i/n) - value )
        d_minus_i=(value-((i-1)/n))
        if d_plus_i > d_plus:
            d_plus = d_plus_i
        if d_minus_i > d_minus:
            d_minus = d_minus_i
        i += 1
    #print(d_plus_i_value, d_minus_i_value)
    return max(d_plus_i, d_minus_i)
    
def autocorrelation_tests( R, n, gap_sequence ):
    little_m = gap_sequence
    start_index = 0
    big_n = n
    big_m = 0.0

    #print((big_n - start_index)/little_m )
    while (big_m + 1) < ( (big_n - start_index)/little_m ) :
        big_m = big_m + 1
    #print(big_m)
    one_over_m_plus_one = ( 1.0/(big_m + 1.0 ) )
    rho_hat = 0.0
    sum_of_rho_hat = 0.0

    every_m_element = R[0::gap_sequence]

    for value in range(0, (len(every_m_element)-1) ):
        thisValue = float(every_m_element[value])
        nextValue = float(every_m_element[value+1])
        sum_of_rho_hat = sum_of_rho_hat + (thisValue * nextValue)

    sum_of_rho_hat = (one_over_m_plus_one * sum_of_rho_hat) - 0.25
    variance_of_rho =  math.sqrt( (13*big_m + 7 )) / (12*(big_m + 1))
    #print("variance of rho: ",variance_of_rho)

    z_statistic = sum_of_rho_hat / variance_of_rho
    return z_statistic



m1=487
a1 = 401
m2=159
a2 = 343
R=list()
seed1=m1-100
seed2=m2-100
cycle=CLCG(m1,m2,a1,a2,seed1,seed2,R)
#print(R[0:300])

d=Kolmogorov_Smirnov(R[:301],300)
z=autocorrelation_tests(R[:301],300,2)
#print(R[:301])

Input_Output(m1,m2,a1,a2,seed1,seed2,cycle,R,d,z)

"""
import random as rnd
import math

def CombineLinearCongruentialGenerator(m1,m2,a1,a2,seed1,seed2,R):
    Y1=seed1
    Y2=seed2
    n=100

    Y1 = a1 * Y1 % m1
    Y2 = a2 * Y2 % m2

    X = (Y1 - Y2) % (m1 - 1)
    preX=X
    cycle=1
    #for i in range (1, n):
    while True:
      #print(X)
      if (X > 0):
        R.append(X/m1)
      elif (X == 0):
        R.append((m1-1)/m1)
      Y1 = a1 * Y1 % m1
      Y2 = a2 * Y2 % m2

      X = (Y1 - Y2) % (m1 - 1)

      if X!=preX:
        cycle+=1
      else : break
    #print(X)
    print("Cycle length: ",cycle)

def Kolmogorov_Smirnov(R,n):
    R=sorted(R)
    d_plus_max = 0
    d_minus_max = 0
    i = 1
    for value in R:
        d_plus_i_value = ( (i/n) - value )
        d_minus_i_value=(value-((i-1)/n))
        if d_plus_i_value > d_plus_max:
            d_plus_max = d_plus_i_value
        if d_minus_i_value > d_minus_max:
            d_minus_max = d_minus_i_value
        i += 1
    #print(d_plus_i_value, d_minus_i_value)
    return max(d_plus_i_value, d_minus_i_value)
    
def autocorrelation_tests( R, n, gap_sequence ):
    little_m = gap_sequence
    start_index = 0
    big_n = n
    big_m = 0.0
    while (big_m + 1) < ( (big_n - start_index)/little_m ) :
        big_m = big_m + 1
    one_over_m_plus_one = ( 1.0/(big_m + 1.0 ) )
    rho_hat = 0.0
    sum_of_rho_hat = 0.0

    every_m_element = R[0::gap_sequence]

    for value in range(0, (len(every_m_element)-1) ):
        thisValue = float(every_m_element[value])
        nextValue = float(every_m_element[value+1])
        sum_of_rho_hat = sum_of_rho_hat + (thisValue * nextValue)

    sum_of_rho_hat = (one_over_m_plus_one * sum_of_rho_hat) - 0.25
    variance_of_rho =  math.sqrt( (13*big_m + 7 )) / (12*(big_m + 1))
    print("variance of rho: ",variance_of_rho)

    z_statistic = sum_of_rho_hat / variance_of_rho
    return z_statistic




m1 = 2147483563
m1=5011
a1 = 4001
m2 = 2147483399
m2=1059
a2 = 4069
R=list()
seed1=m1-100
seed2=m2-100
CombineLinearCongruentialGenerator(m1,m2,a1,a2,seed1,seed2,R)
d=Kolmogorov_Smirnov(R[:301],300)

print("Uniform test: ")
print("Kolmogorov_Smirnov: ")
print("D value is: ",d)


print("Autocorrelation tests: ")
z=autocorrelation_tests(R[:301],300,2)
print("Value of Z: ",z)
#print(R[:301])
"""