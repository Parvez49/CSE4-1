# -*- coding: utf-8 -*-
"""MultiLayerPerceptron.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W-IapGM8hJYp9AfU0FChrReOfb3Iiez9
"""

import math

inputs=[.05,.1,1]
weight1=[[.15,.20,.35],[.25,.30,.35]]
weight2=[[.40,.45,.60],[.50,.55,.60]]
T_outputs=[.01,.99]
eta=.5
iteration=1
Total_iteration=1000

def sigmoid(y):
  return 1/(1+math.exp(-y))

def weighted_sum(input,weight):
  total=0
  for i,j in zip(input,weight):
    total+=i*j
  return total

def layer_output(input,weights):
  node_outputs=[]
  for weight in weights:
    node_input=weighted_sum(input,weight)
    node_output=sigmoid(node_input)
    node_outputs.append(node_output)
  return node_outputs

def error_measure(target,output):
  error=0
  for i,j in zip(target,output):
    error=error+(((i-j)*(i-j))/2)  
  return error

def delta_output(output,target):
  delta_outputs=[]
  for i,j in zip (output,target):
    delta_output=(i*(1-i)*(j-i))
    delta_outputs.append(delta_output)
  return delta_outputs

def delta_hidden(up_weight,up_delta,output):
  delta_hiddens=[]
  for i in range(len(up_weight[0])-1):
    sum=0
    for j in range(len(up_weight[0])-1):
      sum+=up_weight[j][i]*up_delta[j]
      delta_hidden=output[i]*(1-output[i])*sum
    delta_hiddens.append(delta_hidden)
  return   delta_hiddens

def weight_updates(weight,delta,input):
  for i in range(len(weight)):
      for j in range(len(weight[i])):
        weight[i][j]+=eta*delta[i]*input[j]
  return weight

while iteration<=Total_iteration:
  layer1_output=layer_output(inputs,weight1)
  input_hidden=[layer1_output[0],layer1_output[1],1]
  layer2_output=layer_output(input_hidden,weight2)
  error=error_measure(T_outputs,layer2_output)
  #print(error)

  delta2=delta_output(layer2_output,T_outputs)
  weight2=weight_updates(weight2,delta2,input_hidden)
  delta1=delta_hidden(weight2,delta2,input_hidden)
  weight1=weight_updates(weight1,delta1,inputs)
  iteration+=1